# Pay-To-Play Tic-Tac-Toe


&nbsp;&nbsp;&nbsp;&nbsp;litepresence and I (squidKid-deluxe) chose to build Pay-To-Play Tic-Tac-Toe using Reach and JavaScript for a Reach bounty hack as my 7th-grade homeschool science-fair project. Pay-To-Play (P2P) Tic-Tac-Toe (TTT) is a game very similar to regular TTT, except that each place on the board has a fee that is calculated by how many ‘wins’ can be made by utilizing the chosen space. The game was engineered with a few additional features, listed below:
 - Each fee is scaled to the initial wager so that each player never pays more than the full game wager.
 - A double win occurs when a player gets two sets of three-in-a-rows, and that player is awarded their full wager.
 - When the game comes to a tie, each player wins their opponent’s expenditure and loses their own.
 - A 3D version of the game was created by stacking three TTT boards on top of one another.
 - In the 3D version, it was determined that it was impossible for a player to win if their opponent played the center of the cube, so that move was said to be ‘illegal’.

&nbsp;&nbsp;&nbsp;&nbsp;For both the 2D and 3D versions of the game, web and command-line interfaces were created and the web applications were polished as much as possible, with 3D-like perspective planes on the game boards. With the help of litepresence, images were used everywhere in the place of plain colored game board.
At the start of the hack, I was not very confident until I had completed the tutorial and figured out how to get Reach running. The first thing that I did was copy all of the finished CLI code for the Tic-Tac-Toe engine within the reach-lang repository into my working folder. When we first asked the Reach community for help, we were struggling with a balance assertion error. Jay McCarthy, the Reach CTO, told us that we were transferring an incorrect amount to the participants after the game was completed. This was corrected by calculating the end funds to be transferred from the wager so that no participant payed more than the wager, which our invariant statement earlier in the code allowed for.

&nbsp;&nbsp;&nbsp;&nbsp;The 2D version that we made is pretty much the exact same as regular TTT, except for the P2P function discussed earlier. Aided by Reach, this part was not particularly challenging, but was quite the learning experience because it was the first DApp we had ever written. The graphics of the CLI were quite easy, because the workshop render() function had to be changed very little to modify the graphics to a more interesting Calvin-S ASCII-art font ([Github](https://github.com/patorjk/figlet.js)). The graphics for the web application were not too difficult, but the correct positioning on a perspective game board, on different sized monitors, proved to be a time-consuming challenge. In the backend taken from the [reach docs](https://docs.reach.sh), we changed the mathematical calculations from booleans to integers.

&nbsp;&nbsp;&nbsp;&nbsp;The 3D version of P2P TTT had been a ‘Game Mode’ we decided would go onto our list of things to do if given the chance, but when the deadline for Demo Day was extended, we decided to implement it with GUIs similar to what we already had. Developing it was a good deal more difficult than developing the 2D version, mostly due to the complexities of learning the details of Reach matrix math. The consensus steps of the Reach program went fairly unchanged from 2D to 3D, but the globals and functions were greatly modified. A whole new winning function had to be created, and each function to do with the fees had to be re-implemented to make use of the 27-item-long board Array. We ended up discarding the original idea of using a 3x3x3 matrix because of the difficulties of creating the correct data type to be used in passing the board to and from the JS front-end. litepresence came up with a mathematical equation to convert the x, y, z data into a single integer to aid in passing the coordinates of the move from the front-end to the back-end and vice versa.

&nbsp;&nbsp;&nbsp;&nbsp;When attempting to deploy on Algorand, we found that there was a very small byte limit on the size of the compiled consensus steps. Our code for the 2D game originally had a 1600 byte compiled consensus step size, far too large for the Algorand compiler, which wanted less than 1000 bytes. Removing the double-win logic and more efficiently calculating the wins and ties reduced the size of the consensus steps by approximately 200 bytes. Then Jay McCarthy suggested that we try to use Boolean math, rather than the integer math methods that we had adopted. After switching the integer math back to Boolean math, the consensus size was still slightly too large, at 1039 bytes. Then, after shrinking a few of the winning calculations down to one-line or, or || calculations, we finally managed to get the code under the 1000 byte limit. Due to the byte limit, we unfortunately were not able to deploy the 3D version on Algorand.
In conclusion, if given the opportunity, there are a few things that we would like to change about the game itself as well as the Reach language:

 - Game changes would include:
     - We would like to add to the game a ‘play again’ button to allow the players to play again using the same contract.
     - Add a ‘FOMO’ game mode, eg. play until one player is three wins ahead of the other, and wins the total pot of all games played.
     - Add a ‘Best of three’ game mode, where players commit to 3 games and the winner gets the total pot of all three.
     - Add an AI so that the game could be played by only one person and the developer could incur income by bot.
     - Implement a Python chat server with a JS client for chatting and contract info transfer. litepresence has already developed the Python chat server, which can be found on his [Github](https://github.com/litepresence/nescient).

 - Reach language changes / enhancements would include:
     - The error messages were not very helpful, improved stack trace on the Reach end would expedite development.
     - Allowing var or let in regular steps would improve the ability to develop more exotic logic and mathematical statements.
     - Add a larger byte limit to the Algorand compiler so that more in-depth games could be developed on Algorand, rather than Ethereum
     - Add a small Reach compiler app, that informed a developer how many bytes a given constant or function was, to aid in correct sizing for Algorand

&nbsp;&nbsp;&nbsp;&nbsp;The gas fees for Algorand were also a lot smaller than those on Ethereum; to create a $100 contract on ETH, the gas fee was approximately $77, where as on ALGO, the fee was about one tenth of a cent. In the end, building P2P TTT was a lot of fun and work. We thank the reach Discord team for helping us through our many problems, talking us through the deployment on Algorand, and providing financial incentive to learn a new language, through their bounty-hack program.
